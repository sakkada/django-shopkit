# -*- coding:utf-8 -*-
"""
Shopkit (was Satchless, fork of satchless project).
The Django e-commerce framework.

Пример реализации интернет магазина на основе библиотеки shopkit.
Shopkit основан на коде satchless до переделки его из django библиотеки для
создания интернет магазинов в каркас для магазинов, созданных на python.
При этом satchless как магазин переродился в проекте saleor, но из каркаса
(фреймворка) для магазинов превратился в готовую реализацию (т.е. от идеи
создания движка, а не готовых магазинов, наподобие satchmo и LFS, пришли
снова к готовому магазину). Shopkit возвращает идею движка магазинов.

Ранее satchless работал следующим образом:
    Модели хранились и (в некоторых случаях) генерировались непосредственно
    кодом приложений (ShopKitApp), так называемыми магическими приложениями
    (MagicApp).

    Это позволяло динамически подменять любую модель в системе, но при этом
    для подмены моделей ForeignKey полей использовался собственный механизм
    Deferred полей.

    Плюсом подхода являлось полностью динамическая связь моделей друг с другом,
    по большому счету связь была только по имени поля, а модель можно было
    подставить любую. При таком подходе можно было указывать просто имена
    полей (как это сделано в Oscar) и удалить из системы механизм Deferred
    полей. Так же плюсом являлась возможность узнать, какие конкретно модели
    используются в данном проекте, но для этого все равно нужно было знать,
    откуда импортировать само приложение. Т.е. вместо импорта непосредственно,
    например:
        from products.models import Product
    необходимо было импортировать приложение и получать модель из него:
        from products.app import product_app
        product_app.Product
    Но при этом, все равно необходимо было знать путь к product_app.

    Главным минусом же являлось то, что модели хранились непосредственно в
    объекте satchless приложения, а не приложения django, и приходилось для
    корректной работы проекта писать в файлах моделей что то вроде:
        from . import app
        Order = app.Order
        DeliveryGroup = app.DeliveryGroup
        OrderLine = app.OrderLine

    И так же при этом совершенно неверным представлялся (по мнению автора)
    механизм авто генерации моделей при помощи функции construct.

    Shopkit.

    Новый подход предполагает определение моделей классическим, явным способом,
    в модулях models.py приложений django, и при необходимости, указывания их
    в приложениях satchless так же явным способом. При этом все внешние связи в
    полях ForeignKey указываются непосредственно в коде движка с помощью имен
    предполагаемых (как это реализовано в примере example) приложений django и
    моделей Shopkit. Например, связь элемента корзины с вариантом в коде
    shopkit указана как:
        variant = models.ForeignKey('products.Variant',
                                    on_delete=models.CASCADE)
    И предполагается, что приложение товаров будет называться "products", а
    сама модель "Variant". При этом полностью удаляется механизм Deferred
    полей. Это стало возможным после того, как в django добавился функционал
    переопределения полей моделей. Если раньше поля абстрактных моделей в
    дочерних изменять было нельзя без патчей, то теперь, когда это стало
    возможным, при отличных, от предполагаемых, именах приложений и самих
    моделей достаточно лишь переопределить все внешние поля всех используемых
    моделей в конкретной реализации магазина. Этот подход позволяет избавиться
    от лишних механизмов, оставаясь в рамках стандартного подхода django. Этот
    подход, некий компромисс между подходом satchless и oscar.

    Так же внедряется приложение shop_app, в котором уже непосредственно будут
    содержаться ссылки другие приложения системы. При этом объекты приложений
    создаются в самом файле shop/core/app.py непосредственно в проекте,
    с поочередной в строго определенном порядке подгрузкой (и это очень
    важно). Каждое приложение shopkit не должно загружать какие либо элементы
    из других приложений shopkit напрямую, и более того, приложения,
    загружаемые ранее, не должны требовать какие либо компоненты приложений,
    загружаемых позже них на этапе загрузки, только на этапе выполнения (к
    сожалению это ограничение в данный момент обойти не удалось).

    В итоге, по отношению к оригинальному satchless, мы полностью избавляемся
    от Deferred полей и construct механизма, взамен которого будут создаваться
    абстрактные модели с заранее указанными связями.

    Предложение: добавить создание несколько видом абстрактных моделей (
    несколько расширенный аналог поведения из Oscar):
    -   пустая базовая модель без полей, возможно лишь наличие методов
        и свойств (для обозначения общего предка и проверок isinstnace и т.д.)
    -   базовая модель только с ForeignKey и M2M полями с указанием
        лишь на имя модели (order = models.ForeignKey('oredr.Order'))
    -   расширенная базовая модель с остальными полями кроме внешних и M2M.
    В коде проекта программист может использовать любой из этих типов моделей:
    -   если хочется полностью реализовать самостоятельно, первый тип или его
        комбинация со вторым или третьим
    -   если нужно лишь изменить поля модели, не меняя внешние, второй тип
    -   если список полей нет необходимости изменять (только дополнять),
        комбинацию второго и третьего.

    Единственное, что не было перенесено в новый подход, это то, что ранее
    модель указывалась однажды в приложении satchless, и далее если было
    необходимо получить ее, создать ForeignKey поле и т.п., программист
    получал поле из объекта приложения satchless. Теперь же приложения и модели
    как бы живут своими жизнями, приложения работают классическим способом,
    а вот если необходимо получить в приложениях модель из другого приложения,
    используются значения из приложений, а не код (как в oscar):
        django apps.get_model('product.Product')
    пишется что то вроде:
        from shop.core.app import shop_app
        shop_app.product_app.Product
    Главное приемущество такого подхода (в отличие от подхода из Oscar
    с получением моделей через get_model) в том, что мы можем иметь несколько
    приложений магазинов в одном проекте, и даже в одном инстансе django
    с разными моделями product, и разным набором приложений, к примеру
    один проект имеет и каталог, корзину и заказы, а другой только каталог.
    При этом внешние поля, как и описывалось ранее, переопределяются во всех
    приложениях, где это необходимо.

    Главный посыл подхода, в отличие от Oscar, нового saleor, совпадает с
    посылом старого satchless, расширить возможно все, предоставить несколько
    уровней абстракций, от низшего до почти готового. При этом мы стараемся
    учесть проблемы старого satchless, и взять все лучшее (имхо) из Oscar
    и saleor. Shopkit, как и saleor, использует satchless нового типа в основе
    (пока они не намутили чего то страшного совсем у себя;)), за исключением
    механизма шагов чекаута и корзины.

    Так же, на втором этапе переработки старого satchless в shopkit был внесен
    ряд важных изменений, упрощающих внутреннее устроство как самой библиотеки,
    так и конкретной реализации магазина.

    1.  Удален механизм CheckMixin, который был попыткой заменить Deferred
        поля, до того, как стало возможным переопределять поля в моделях.
    2.  Полностью удалена очередь обработки сигнала on_product_view queue, и
        все что с ней связано, в том числе Handler из приложения cart,
        запутанный механизм регистрации форм для моделей продуктов и вариантов,
        и теперь внедрение зависимостей из сторонних приложений автоматическим
        способом невозможно, программист должен сам добавить код в приложение
        ProductApp, что делает общий код реализации более понятным и
        предсказуемым, хот и весь процесс при этом, на первый взгляд становится
        более трудоемким.
    3.  Так же, и это связано с предыдущим пунктом, полностью удален механизм
        наследования моделей продуктов и вариантов, модель продукта и варианта
        теперь только одна, проблемы динамических наборов полей должны решаться
        в конкретной реализации. При сильном желании, возможно воспользоваться,
        например, функционалом InheritanceManager и модуля model_utils.
        При этом, стало возможным удалить механизм регистрации форм для
        продуктов и оставить только одну форму на всех. Так же теперь нет
        необходимости всюду вызывать метод get_subtype_instance.
    4.  Удален функционал @view декоратора, все конфигурации url теперь
        указываются непосредственно в методе get_urls (как в oscar). При этом,
        если предков у приложения, имеющих реализованный метод get_urls, больше
        одного, рекомендуется полностью переопределять весь метод в реализоции,
        что будет значительно более наглядно, нежели вызов метода у классов
        предков.
    5.  Некоторое количество полей было переименовано, для достижения более
        ясной картины в вопросе имен и избавления от двусмысленности.
    6.  В модели и приложения заказов и корзин был добавлен функционал проверки
        заказов и корзин и изъятия/возврата товаров со склада.
    7.  Добавлен пример реализации приложения магазина в котором показан
        предполагаемый автором подход к построению магазинов на shopkit.

    Last original satchless commit in django-satchless is:
        162370f2fdb4acf4737c986fde6725aab5ba62da (committed on 25 Feb 2013)
        https://github.com/mirumee/satchless/commit/162370f
"""

VERSION = (1, 11, 0)

"""
cart            - app/shoppart prototype
checkout        - app/shoppart prototype
contrib         - predefined functionality
core            - core
delivery        - app/shoppart prototype
order           - app/shoppart prototype
payment         - app/shoppart prototype
product         - app/shoppart prototype
utils           - additional utils
__init__.py     - this file
"""
