# -*- coding:utf-8 -*-
"""
Ранее satchless работал следующим образом:
    Модели хранились и (в некоторых случаях) генерировались непосредственно
    кодом приложений (SatchlessApp), так называемыми магическими приложениями.

    Это позволяло динамически подменять любую модель в системе, но при этом
    для подмены моделей ForeignKey полей использовался собственный механизм
    Deffered полей.

    Плюсом подхода являлось полностью динамическая связь моделей друг с другом,
    по большому счету связь была только по имени поля, а модель можно было 
    подставить любую для этого. При таком подходе можно было указывать просто
    имена полей (как это сделано в Oscar) и удалить из системы механизм Deffered
    полей. Так же плюсом являлось возможность узнать какие конкретно модели
    в используются в данном проекте, но для этого все равно нужно было знать,
    откуда импортировать само приложение (т.е. вместо импорта непосредственно,
    например,
        from products.modela import Product
    можно сделано
        from products.app import product_app
        product_app.Product
    Но все равно необходимо знать откуда импортировать product_app.

    Главным минусом же являлось то, что модели хранились непосредственно в объекте
    satchless приложения, а не приложения django, и приходилось для корректной
    работы проекта писать в файлах моделей что то вроде:
        from . import app

        Order = app.Order
        DeliveryGroup = app.DeliveryGroup
        OrderedItem = app.OrderedItem

    И так же при этом совершенно неверным представляется механизм автогенерации
    моделей при помощи функции construct.
    
    Новый подход предполагает генерацию моделей классическим, ЯВНЫМ способом,
    в модулях models.py приложений django, и при необходимости указывания их
    в приложениях satchless так же явным способом.
    Так же внедряется приложение shop_app, в котором уже непосредственно будут
    содержаться ссылки на другие приложения системы. При этом объекты приложений
    создаются в самом файле shop/core/app.py непосредственно в проекте,
    с поочередной подгрузкой с необходимым порядком подгрузки.

    Предполагается полностью избавиться от Deffered полей и construct механизма,
    взамен которого будут создаваться несколько видом абстрактных моделей (
    несколько расширенный аналог поведения из Oscar):
        - пустая базовая модель без полей, возможность лишь наличие методов
          и свойств (для обозначения общего предка и проверок isinstnace и т.п.)
        - базовая модель без ForeignKey и M2M полей
        - расширенная базовая модель с добавленными ForeignKey и M2M с указанием
          лишь на имя модели (order = models.ForeignKey('oredr.Order'))

    В коде же проекта программист может использовать любой из этих типов моделей:
        - если хочется полностью реализовать самостоятельно, первый тип
        - если нужно лишь изменить связи, второй тип
        - если список полей нет необходимости изменять (только дополнять), третий

    Единственное, что не было перенесено в новый подход, это то, что ранее
    модель указывалась однажды в приложении satchless, и далее если было
    необходимо получить ее, создать ForeignKey поле и т.п., программист
    получал поле из объекта приложения satchless. Теперь же приложения и модели
    как бы живут своими жизнями, приложения работают классическим способом,
    а вот если необходимо получить в приложениях модель из другого приложения,
    используются значения из приложений, а не код:
        django apps.get_model('product.Product')
    пишется что что вроде:
        from shop.core.app import shop_app
        shop_app.product_app.Product
    Главное приемущество такого подхода (в отличие от подхода из Oscar
    с получением моделей через get_model) в том, что мы можем иметь несколько
    приложений магазинов в одном проекте, и даже в одном инстансе django
    с разными моделями product, и разным набором приложений, к примеру
    один проект имеет и каталог, корзину и заказы, а другой только каталог.
    (todo: продумать разные namespace для приложений)
    Хотя если программист уверен что проект только один, предпочтительней
    все же использовать get_model механизм.

    Главный посыл подхода, в отличие от Oscar, нового saleor, совпадает с
    посылом старого satchless, расширить возможно все, предоставить несколько
    уровней абстракций, от нисшего до почти готового. При этом мы стараемся
    учесть проблемы старого satchless, и взять все лучшее (имхо) из Oscar
    и saleor. Shopkit как и saleor использует satchless нового типа в основе (
    пока они не намутили чего то страшного совсем у себя;)), за исключением
    механизма шагов чекаута.
"""
